---
This page describes the smart contract used for attestations
---

# Attestations

Attestations are the ratings or opinions given by one peer about another peer in the EigenTrust protocol. Each attestation is given for a single transaction or interaction between peers.

The structure of an attestation is defined as follows:
```rust
struct Attestation<F: FieldExt> {
    about: F,
    key: F,
    value: F,
    message: F
}
```

Here's a breakdown of each field in the attestation:

- `about`: the Ethereum address of the peer being rated. This could be an EOA, a smart contract, a DAO, etc.
- `key`: a unique identifier for the transaction or interaction being rated. This could be a hash of the transaction data or a random number generated by the rater.
- `value`: the score given by the rater for the transaction or interaction. The score can range from 0 to a maximum score defined as a constant in the protocol.
- `message`: an optional field for attaching additional information to the attestation. This could be a message from the rater, a domain in which the transaction took place, or a content hash related to the transaction.

To ensure the integrity and authenticity of an attestation, it is hashed using the Poseidon hash function and then signed using the ECDSA signing algorithm:
```rust
let att_hash = Poseidon::hash(attestation);
let sig = ECDSA::sign(att_hash, keys);
```
The resulting signature, value and message bytes are stored in the AttestationStation smart contract. The bytes layout would be:
```rust
r = [u8; 32]
s = [u8; 32]
value = u8
message = [u8; 32]
```
This adds up to 97 bytes or 65 if we exclude message bytes.

In case of fetching the attestation from AS and verifying it - first, we read the event:
```solidity
event AttestationCreated(
    address indexed creator,
    address indexed about,
    bytes32 indexed key,
    bytes val
);
```

Using this data, we extract the `r` and `s`, we verify the signature:
```rust
let (r, s, value, message) = extract_r_s_value_message(val);
let att = Attestation::new(about, key, value, message);
let hash = Poseidon::hash(att);
let is_valid = ECDSA::verify(pub_key, r, s, hash);
assert!(is_valid);
```

Then check if the used `pub_key` is actually the pre-image of the `creator`:
```rust
let pk_hash = keccak256(pub_key);
let creator_address = to_address(pk_hash);
assert!(creator_address == creator);
```

See [AttestationStation](../0_attestation_station.md) for more details on how attestations are stored and managed in the EigenTrust protocol.

By signing the attestation, the rater can prove that they made the rating and that the rating has not been tampered with. This is important for verifying the validity of the attestation in an off-chain environment, such as when calculating the EigenTrust scores for each peer.
